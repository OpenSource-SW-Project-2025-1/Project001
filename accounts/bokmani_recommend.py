# -*- coding: utf-8 -*-
"""Bokmani_recommend.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bYfpHmpZBkt3nTrlZY16X5N1EAiMH6rR
"""

# -*- coding: utf-8 -*-
# 필요한 라이브러리 임포트 (기존과 동일)
import string
import numpy as np
import pandas as pd
import re
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
import warnings
warnings.filterwarnings('ignore')

# 이 코드는 Colab 환경 또는 필요한 파일이 로컬에 준비된 환경에서 실행되어야 합니다.
# from google.colab import drive
# drive.mount('/content/drive')
# folder_path = '/content/drive/MyDrive/인천광역시_소득데이터_20200630'
# ... (데이터 로딩 및 EDA 부분은 기존 스크립트와 동일하게 실행되었다고 가정) ...

# -------------------------------------------------------------
# 1. 텍스트 정제 클래스 (기존과 동일)
# -------------------------------------------------------------
class TextCleaner:
    def separate_text(self, texts):
        if not isinstance(texts, str):
            return ""
        unique_texts = {text.strip().lower() for text in texts.split(',')}
        return ' '.join(sorted(unique_texts))

    def remove_space(self, text):
        if not isinstance(text, str):
            return ""
        return text.replace(' ', '').lower()

    def remove_punc(self, text):
        if not isinstance(text, str):
            return ""
        text = text.lower()
        text = text.translate(str.maketrans('', '', string.punctuation))
        return ' '.join(text.split())

cleaner = TextCleaner()

# -------------------------------------------------------------
# 2. 복지 데이터 정의 및 전처리 강화
# -------------------------------------------------------------
# 참고: 실제 시스템에서는 DB나 파일에서 로드해야 합니다.
복지_데이터 = [
    {"서비스명": "청년 월세 지원", "최대소득": 250, "직업조건": "무직,프리랜서", "연령조건": "19~34세", "계층조건": "저소득 청년", "관심주제": "주거지원", "제공방식": "현금", "신청주기": "월", "개요": "청년의 주거비 부담을 줄이기 위한 월세 지원 사업입니다."},
    {"서비스명": "노인 기초연금", "최대소득": 150, "직업조건": "무직", "연령조건": "65세 이상", "계층조건": "저소득 노인", "관심주제": "소득보장", "제공방식": "현금", "신청주기": "매월", "개요": "소득 하위 70% 노인에게 지급되는 기초연금입니다."},
    {"서비스명": "장애인 활동 지원", "최대소득": 300, "직업조건": "상관없음", "연령조건": "6세 이상", "계층조건": "등록 장애인", "관심주제": "생활지원", "제공방식": "바우처", "신청주기": "월", "개요": "일상생활이 어려운 장애인의 자립을 위한 활동 지원 서비스"},
    {"서비스명": "영유아 보육료 지원", "최대소득": 350, "직업조건": "보호자 필요", "연령조건": "0~5세", "계층조건": "영유아가구", "관심주제": "육아지원", "제공방식": "현금", "신청주기": "월", "개요": "어린이집 보육료를 국가가 지원하는 제도입니다."},
    {"서비스명": "취업성공패키지", "최대소득": 400, "직업조건": "구직자", "연령조건": "18~65세", "계층조건": "실업자,저소득층", "관심주제": "일자리", "제공방식": "서비스", "신청주기": "회차별", "개요": "맞춤형 취업지원 프로그램과 훈련비를 지원하는 제도입니다."}
]
복지_제도_리스트 = pd.DataFrame(복지_데이터)

# --- 핵심 개선 사항: 구조화된 데이터 파싱 ---
def parse_age_condition(age_text):
    """연령조건 텍스트를 파싱하여 최소, 최대 연령을 반환"""
    age_text = str(age_text).strip()
    if '이상' in age_text:
        min_age = int(re.findall(r'\d+', age_text)[0])
        return min_age, 150 # 최대 연령을 임의의 큰 수로 설정
    elif '~' in age_text:
        ages = re.findall(r'\d+', age_text)
        return int(ages[0]), int(ages[1])
    elif '상관없음' in age_text or not age_text:
        return 0, 150
    else:
        return 0, 150 # 처리할 수 없는 경우 전체 연령 허용

# '최대소득'을 숫자로 변환
복지_제도_리스트['최대소득'] = pd.to_numeric(복지_제도_리스트['최대소득'], errors='coerce')

# '연령조건'에서 '최소연령', '최대연령' 파생 변수 생성
복지_제도_리스트[['최소연령', '최대연령']] = 복지_제도_리스트['연령조건'].apply(lambda x: pd.Series(parse_age_condition(x)))

print("--- 전처리 후 복지 데이터 (연령/소득 처리) ---")
display(복지_제도_리스트[['서비스명', '최대소득', '최소연령', '최대연령']].head())


# -------------------------------------------------------------
# 3. 콘텐츠 기반 분석을 위한 BoW 생성 및 TF-IDF 계산 (기존과 유사)
# -------------------------------------------------------------
# 추천의 '순위'를 매길 때 사용할 텍스트 정보 결합
복지_제도_리스트['BoW'] = (
    복지_제도_리스트['관심주제'].apply(cleaner.separate_text) + ' ' +
    복지_제도_리스트['계층조건'].apply(cleaner.separate_text) + ' ' +
    복지_제도_리스트['개요'].apply(cleaner.remove_punc)
)

tfidf = TfidfVectorizer()
tfidf_matrix = tfidf.fit_transform(복지_제도_리스트['BoW'])


# -------------------------------------------------------------
# 4. 통합 추천 시스템 (하이브리드 방식)
# -------------------------------------------------------------
class HybridWelfareRecommender:
    def __init__(self, df, vectorizer, tfidf_matrix):
        self.df = df.copy()
        self.tfidf = vectorizer
        self.tfidf_matrix = tfidf_matrix
        # TF-IDF 행렬과 원본 DataFrame의 인덱스를 매핑
        self.df['matrix_idx'] = range(len(df))

    def recommend(self, user_profile, top_n=5):
        """
        사용자 프로필을 기반으로 필터링과 랭킹을 수행하는 하이브리드 추천
        - user_profile (dict): {'age': int, 'income': int, 'job': str, 'interests': str}
        """
        eligible_df = self.df.copy()

        # --- 1단계: 자격 요건 필터링 (Rule-Based Filtering) ---
        print("\n--- 1단계: 자격 요건 필터링 시작 ---")

        # 나이 필터링
        if 'age' in user_profile:
            age = user_profile['age']
            eligible_df = eligible_df[(eligible_df['최소연령'] <= age) & (eligible_df['최대연령'] >= age)]
            print(f"나이({age}세) 필터링 후 {len(eligible_df)}개 서비스 후보")

        # 소득 필터링 (사용자 월 소득이 서비스의 최대소득 기준 이하)
        if 'income' in user_profile:
            income = user_profile['income']
            # 소득 기준이 없는(NaN) 서비스는 필터링에서 제외하지 않음
            eligible_df = eligible_df[eligible_df['최대소득'].isnull() | (eligible_df['최대소득'] >= income)]
            print(f"소득({income}만원) 필터링 후 {len(eligible_df)}개 서비스 후보")

        # 직업 필터링 (간단한 포함 여부 확인)
        if 'job' in user_profile:
            job = user_profile['job']
            eligible_df = eligible_df[
                eligible_df['직업조건'].str.contains(job, na=False) | (eligible_df['직업조건'] == '상관없음')
            ]
            print(f"직업('{job}') 필터링 후 {len(eligible_df)}개 서비스 후보")

        if eligible_df.empty:
            return "현재 조건에 맞는 복지 서비스를 찾을 수 없습니다.", pd.DataFrame()

        print("최종 필터링 후 대상 서비스 수:", len(eligible_df))

        # --- 2단계: 관심사 기반 순위 선정 (Content-Based Ranking) ---
        print("\n--- 2단계: 관심사 기반 순위 선정 시작 ---")

        # 필터링된 서비스들의 TF-IDF 벡터만 추출
        eligible_indices = eligible_df['matrix_idx'].tolist()
        eligible_tfidf_matrix = self.tfidf_matrix[eligible_indices]

        # 사용자 관심사를 벡터로 변환
        user_bow = cleaner.separate_text(user_profile.get('interests', ''))
        user_vec = self.tfidf.transform([user_bow])

        # 유사도 계산
        sim_scores = cosine_similarity(user_vec, eligible_tfidf_matrix).flatten()
        eligible_df['유사도'] = sim_scores

        # 유사도 기준으로 정렬
        results = eligible_df.sort_values(by='유사도', ascending=False)

        return "추천 결과:", results.head(top_n)[['서비스명', '개요', '유사도']]

# -------------------------------------------------------------
# 5. 추천 시스템 사용 예시
# -------------------------------------------------------------
# 추천기 인스턴스 생성
recommender = HybridWelfareRecommender(복지_제도_리스트, tfidf, tfidf_matrix)

# --- 사용자 1: 주거 지원에 관심있는 30세 프리랜서 ---
print("\n=============================================")
print("사용자 1: 30세, 월 소득 240만원, 프리랜서, 관심사: 주거지원")
user1 = {'age': 30, 'income': 240, 'job': '프리랜서', 'interests': '주거지원 월세'}
title, recommendations = recommender.recommend(user1)
print("\n" + title)
display(recommendations)

# --- 사용자 2: 일자리에 관심있는 25세 구직자 ---
print("\n=============================================")
print("사용자 2: 25세, 월 소득 180만원, 구직자, 관심사: 일자리 취업")
user2 = {'age': 25, 'income': 180, 'job': '구직자', 'interests': '일자리 취업'}
title, recommendations = recommender.recommend(user2)
print("\n" + title)
display(recommendations)

# --- 사용자 3: 소득 기준 초과로 필터링되는 경우 ---
print("\n=============================================")
print("사용자 3: 40세, 월 소득 500만원, 회사원, 관심사: 주거지원")
user3 = {'age': 40, 'income': 500, 'job': '회사원', 'interests': '주거지원'}
title, recommendations = recommender.recommend(user3)
print("\n" + title)
display(recommendations)